/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.mahout.classifier.naivebayes


import org.apache.mahout.classifier.{ResultAnalyzer, ClassifierResult}
import org.apache.mahout.math._
import scalabindings._
import scalabindings.RLikeOps._
import drm.RLikeDrmOps._
import drm._
import scala.reflect.ClassTag
import scala.language.asInstanceOf
import collection._
import JavaConversions._
import scala.collection.JavaConversions._

import org.apache.mahout.classifier.naivebayes.training.ComplementaryThetaTrainer

/**
 * Distributed training of a Naive Bayes model. Follows the approach presented in Rennie et.al.: Tackling the poor
 * assumptions of Naive Bayes Text classifiers, ICML 2003, http://people.csail.mit.edu/jrennie/papers/icml03-nb.pdf
 */
trait NaiveBayes {

  /** default value for the Laplacian smoothing parameter */
  def defaultAlphaI = 1.0f

  // function to extract categories from string keys
  type CategoryParser = String => String

  /** Default: seqdirectory/seq2Sparse Categories are Stored in Drm Keys as: /Category/document_id */
  def seq2SparseCategoryParser: CategoryParser = x => x.split("/")(1)


  /**
   * Distributed training of a Naive Bayes model. Follows the approach presented in Rennie et.al.: Tackling the poor
   * assumptions of Naive Bayes Text classifiers, ICML 2003, http://people.csail.mit.edu/jrennie/papers/icml03-nb.pdf
   *
   * @param observationsPerLabel a DrmLike[Int] matrix containing term frequency counts for each label.
   * @param trainComplementary whether or not to train a complementary Naive Bayes model
   * @param alphaI smoothing parameter
   * @return trained naive bayes model
   */
  def trainNB (observationsPerLabel: DrmLike[Int],
               labelIndex: Map[String, Integer],
               trainComplementary: Boolean = true,
               alphaI: Float = defaultAlphaI): NBModel = {

    // Summation of all weights per feature
    val weightsPerFeature = observationsPerLabel.colSums

    // Distributed summation of all weights per label
    val weightsPerLabel = observationsPerLabel.rowSums

    // Collect a matrix to pass to the NaiveBayesModel
    val inCoreTFIDF = observationsPerLabel.collect

    // perLabelThetaNormalizer Vector is expected by NaiveBayesModel. We can pass a null value
    // or Vector of zeroes in the case of a standard NB model.
    var thetaNormalizer = weightsPerFeature.like()

    // Instantiate a trainer and retrieve the perLabelThetaNormalizer Vector from it in the case of
    // a complementary NB model
    if (trainComplementary) {
      val thetaTrainer = new ComplementaryThetaTrainer(weightsPerFeature, weightsPerLabel, alphaI)
      // local training of the theta normalization
      for (labelIndex <- 0 until inCoreTFIDF.nrow) {
        thetaTrainer.train(labelIndex, inCoreTFIDF(labelIndex, ::))
      }
      thetaNormalizer = thetaTrainer.retrievePerLabelThetaNormalizer()
    }

    new NBModel(inCoreTFIDF,
                weightsPerFeature,
                weightsPerLabel,
                thetaNormalizer,
                labelIndex,
                alphaI,
                trainComplementary)
  }

  /**
   * Extract label Keys from raw TF or TF-IDF Matrix generated by seqdirectory/seq2sparse
   * and aggregate TF or TF-IDF values by their label
   * Override this method in engine specific modules to optimize
   *
   * @param stringKeyedObservations DrmLike matrix; Output from seq2sparse
   *   in form K = eg./Category/document_title
   *           V = TF or TF-IDF values per term
   * @param cParser a String => String function used to extract categories from
   *   Keys of the stringKeyedObservations DRM. The default
   *   CategoryParser will extract "Category" from: '/Category/document_id'
   * @return  (labelIndexMap,aggregatedByLabelObservationDrm)
   *   labelIndexMap is a HashMap [String, Integer] K = label row index
   *                                                V = label
   *   aggregatedByLabelObservationDrm is a DrmLike[Int] of aggregated
   *   TF or TF-IDF counts per label
   */
  def extractLabelsAndAggregateObservations[K: ClassTag]
    (stringKeyedObservations: DrmLike[K], cParser: CategoryParser = seq2SparseCategoryParser)
    (implicit ctx: DistributedContext):
    (mutable.HashMap[String, Integer], DrmLike[Int]) = {

    //implicit val distributedContext = stringKeyedObservations.context

    stringKeyedObservations.checkpoint()

    val numDocs=stringKeyedObservations.nrow
    val numFeatures=stringKeyedObservations.ncol

    // Extract categories from labels assigned by seq2sparse
    // Categories are Stored in Drm Keys as eg.: /Category/document_id

    // Get a new DRM with a single column so that we don't have to collect the
    // DRM into memory upfront.
    val strippedObeservations= stringKeyedObservations.mapBlock(ncol=1){
      case(keys, block) =>
        val blockB = block.like(keys.size, 1)
        keys -> blockB
    }

    // Extract the row label bindings (the String keys) from the slim Drm
    // strip the document_id from the row keys keeping only the category.
    // Sort the bindings aplhabetically into a Vector
    val labelVectorByRowIndex = strippedObeservations
                                  .getRowLabelBindings
                                  .map(x => x._2 -> cParser(x._1))
                                  .toVector.sortWith(_._1 < _._1)

    // Copy stringKeyedObservations to an Int-Keyed Drm so that we can compute transpose
    /* Copy the Collected Matrices up front
      val inCoreStringKeyedObservations = stringKeyedObservations.collect
      val inCoreIntKeyedObservations = new SparseMatrix(
                              stringKeyedObservations.nrow.toInt,
                              stringKeyedObservations.ncol)
      for (i <- 0 until inCoreStringKeyedObservations.nrow.toInt) {
        inCoreIntKeyedObservations(i, ::) = inCoreStringKeyedObservations(i, ::)
      }
      val intKeyedObservations= drmParallelize(inCoreIntKeyedObservations)
    */

    // Copy the Distributed Matrices. Iterate through and bind one column at a time.
    // Very inefficient, but keeps us from pulling the full dataset upfront.
    var singleColumnInCore= sparse(stringKeyedObservations.collect(::, 0)).t
    var singleColumnDrm=drmParallelize(singleColumnInCore)
    var intKeyedObservations = drmParallelize(singleColumnInCore)
    for (i <- 1 until numFeatures) {
      singleColumnInCore= sparse(stringKeyedObservations.collect(::, i)).t
      singleColumnDrm = drmParallelize(singleColumnInCore)
      intKeyedObservations = intKeyedObservations cbind drmParallelize(singleColumnInCore)
    }

    stringKeyedObservations.uncache()

    var labelIndex = 0
    val labelIndexMap = new mutable.HashMap[String, Integer]
    val encodedLabelByRowIndexVector = new DenseVector(labelVectorByRowIndex.size)
    
    // Encode Categories as an Integer (Double) so we can broadcast as a vector
    // where each element is an Int-encoded category whose index corresponds
    // to its row in the Drm
    for (i <- 0 until labelVectorByRowIndex.size) {
      if (!(labelIndexMap.contains(labelVectorByRowIndex(i)._2))) {
        encodedLabelByRowIndexVector(i) = labelIndex.toDouble
        labelIndexMap.put(labelVectorByRowIndex(i)._2, labelIndex)
        labelIndex += 1
      }
      // don't like this casting but need to use a java.lang.Integer when setting rowLabelBindings
      encodedLabelByRowIndexVector(i) = labelIndexMap
                                          .getOrElse(labelVectorByRowIndex(i)._2, -1)
                                          .asInstanceOf[Int].toDouble
    }

    // "Combiner": Map and aggregate by Category. Do this by broadcasting the encoded
    // category vector and mapping a transposed IntKeyed Drm out so that all categories
    // will be present on all nodes as columns and can be referenced by
    // BCastEncodedCategoryByRowVector.  Iteratively sum all categories.
    val nLabels = labelIndex

    val bcastEncodedCategoryByRowVector = drmBroadcast(encodedLabelByRowIndexVector)

    val aggregetedObservationByLabelDrm = intKeyedObservations.t.mapBlock(ncol = nLabels) {
      case (keys, blockA) =>
        val blockB = blockA.like(keys.size, nLabels)
        var label : Int = 0
        for (i <- 0 until keys.size) {
          blockA(i, ::).nonZeroes().foreach { elem =>
            label = bcastEncodedCategoryByRowVector.get(elem.index).toInt
            blockB(i, label) = blockB(i, label) + blockA(i, elem.index)
          }
        }
        keys -> blockB
    }.t

    // Now return the label Index HashMap and the the
    // aggregetedObservationDrm which can be used as input to trainNB
    (labelIndexMap, aggregetedObservationByLabelDrm)
  }

  def testNB[K: ClassTag](model: NBModel, testSet: DrmLike[K]): Unit ={

    val labelMap = model.labelIndex

    val numLabels = model.numLabels

    val numTestInstances = testSet.nrow.toInt

    val classifier = model match {
      case xx if model.isComplementary => new ComplementaryNBClassifier(model)
      case _ => new StandardNBClassifier(model)
    }

    val scoredTestSet = testSet.mapBlock(ncol = numLabels){
      case (keys, block)=>
        val numInstances = keys.size
        val blockB= block.like(numInstances, numLabels)
        for(i <- 0 until numInstances){
          blockB(i, ::) := classifier.classifyFull(block(i, ::) )
        }
        keys -> blockB
    }

    // may want to strip this down if we think that numDocuments x numLabels wont fit into memory
    val testSetLabelMap = scoredTestSet.getRowLabelBindings

    // todo:XXX: reverse the labelMaps in training and through the model?
    val reverseTestSetLabelMap = mapAsScalaMap(testSetLabelMap).map(x => x._2 -> x._1)

    val reverseLabelMap = mapAsScalaMap(labelMap).map(x => x._2 -> x._1)

    val analyzer: ResultAnalyzer = new ResultAnalyzer(labelMap.keys, "DEFAULT")

    // need to do this with out collecting
    val inCoreScoredTestSet = scoredTestSet.collect

    for(i <- 0 until numTestInstances){
      val (bestIdx, bestScore) = argmax(inCoreScoredTestSet(i,::))
      val classifierResult = new ClassifierResult(reverseLabelMap(bestIdx), bestScore)
      analyzer.addInstance(reverseTestSetLabelMap(i), classifierResult)
    }
  }

  // argmax with values as well
  def argmax(v: Vector): (Int, Double) = {
    var bestIdx: Int = Integer.MIN_VALUE
    var bestScore: Double = Integer.MIN_VALUE.asInstanceOf[Int].toDouble
    for(i <-0 until v.length) {
      if(v(i) > bestScore){
        bestScore = v(i)
        bestIdx = i
      }
    }
    (bestIdx, bestScore)
  }


}

object NaiveBayes extends NaiveBayes
