"use strict";(globalThis.webpackChunkmahout_website=globalThis.webpackChunkmahout_website||[]).push([[4881],{4238(e,i,n){n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"qumat/api","title":"Api","description":"init(self, backend_config)","source":"@site/docs/qumat/api.md","sourceDirName":"qumat","slug":"/qumat/api","permalink":"/docs/next/qumat/api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/mahout/tree/main/docs/docs/qumat/api.md","tags":[],"version":"current","frontMatter":{"title":"Api"},"sidebar":"docsSidebar","previous":{"title":"Parameterized Circuits","permalink":"/docs/next/qumat/parameterized-circuits"},"next":{"title":"Core Concepts - Qumat","permalink":"/docs/next/qumat/concepts"}}');var s=n(4848),l=n(8453);const r={title:"Api"},a="QuMat Class Methods",d={},c=[{value:"<code>__init__(self, backend_config)</code>",id:"__init__self-backend_config",level:2},{value:"<code>create_empty_circuit(self, num_qubits)</code>",id:"create_empty_circuitself-num_qubits",level:2},{value:"<code>apply_not_gate(self, qubit_index)</code>",id:"apply_not_gateself-qubit_index",level:2},{value:"<code>apply_hadamard_gate(self, qubit_index)</code>",id:"apply_hadamard_gateself-qubit_index",level:2},{value:"<code>apply_cnot_gate(self, control_qubit_index, target_qubit_index)</code>",id:"apply_cnot_gateself-control_qubit_index-target_qubit_index",level:2},{value:"<code>apply_toffoli_gate(self, control_qubit_index1, control_qubit_index2, target_qubit_index)</code>",id:"apply_toffoli_gateself-control_qubit_index1-control_qubit_index2-target_qubit_index",level:2},{value:"<code>apply_swap_gate(self, qubit_index1, qubit_index2)</code>",id:"apply_swap_gateself-qubit_index1-qubit_index2",level:2},{value:"<code>apply_cswap_gate(self, control_qubit_index, target_qubit_index1, target_qubit_index2)</code>",id:"apply_cswap_gateself-control_qubit_index-target_qubit_index1-target_qubit_index2",level:2},{value:"<code>apply_pauli_x_gate(self, qubit_index)</code>",id:"apply_pauli_x_gateself-qubit_index",level:2},{value:"<code>apply_pauli_y_gate(self, qubit_index)</code>",id:"apply_pauli_y_gateself-qubit_index",level:2},{value:"<code>apply_pauli_z_gate(self, qubit_index)</code>",id:"apply_pauli_z_gateself-qubit_index",level:2},{value:"<code>apply_t_gate(self, qubit_index)</code>",id:"apply_t_gateself-qubit_index",level:2},{value:"<code>execute_circuit(self)</code>",id:"execute_circuitself",level:2},{value:"<code>get_final_state_vector(self)</code>",id:"get_final_state_vectorself",level:2},{value:"<code>draw_circuit(self)</code>",id:"draw_circuitself",level:2},{value:"<code>apply_rx_gate(self, qubit_index, angle)</code>",id:"apply_rx_gateself-qubit_index-angle",level:2},{value:"<code>apply_ry_gate(self, qubit_index, angle)</code>",id:"apply_ry_gateself-qubit_index-angle",level:2},{value:"<code>apply_rz_gate(self, qubit_index, angle)</code>",id:"apply_rz_gateself-qubit_index-angle",level:2},{value:"<code>apply_u_gate(self, qubit_index, theta, phi, lambd)</code>",id:"apply_u_gateself-qubit_index-theta-phi-lambd",level:2},{value:"<code>execute_circuit(self, parameter_values=None)</code>",id:"execute_circuitself-parameter_valuesnone",level:2},{value:"<code>bind_parameters(self, parameter_values)</code>",id:"bind_parametersself-parameter_values",level:2},{value:"<code>_handle_parameter(self, param_name)</code>",id:"_handle_parameterself-param_name",level:2},{value:"<code>swap_test(self, ancilla_qubit, qubit1, qubit2)</code>",id:"swap_testself-ancilla_qubit-qubit1-qubit2",level:2},{value:"<code>measure_overlap(self, qubit1, qubit2, ancilla_qubit=0)</code>",id:"measure_overlapself-qubit1-qubit2-ancilla_qubit0",level:2}];function o(e){const i={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"qumat-class-methods",children:"QuMat Class Methods"})}),"\n",(0,s.jsx)(i.h2,{id:"__init__self-backend_config",children:(0,s.jsx)(i.code,{children:"__init__(self, backend_config)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Initializes the QuMat instance with a specific backend."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"backend_config"})," (dict): Configuration for the backend including its name and options."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Used to set up the quantum computing backend based on user configuration."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"create_empty_circuitself-num_qubits",children:(0,s.jsx)(i.code,{children:"create_empty_circuit(self, num_qubits)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Creates an empty quantum circuit with a specified number of qubits."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"num_qubits"})," (int): Number of qubits in the quantum circuit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Used at the start of quantum computations to prepare a new quantum circuit."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_not_gateself-qubit_index",children:(0,s.jsx)(i.code,{children:"apply_not_gate(self, qubit_index)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a NOT gate (quantum equivalent of a classical NOT) to a specified qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index"})," (int): Index of the qubit to which the gate is applied."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Used to flip the state of a qubit from 0 to 1 or from 1 to 0."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_hadamard_gateself-qubit_index",children:(0,s.jsx)(i.code,{children:"apply_hadamard_gate(self, qubit_index)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a Hadamard gate to a specified qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index"})," (int): Index of the qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Used to create a superposition state, allowing the qubit to be both 0 and 1 simultaneously."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_cnot_gateself-control_qubit_index-target_qubit_index",children:(0,s.jsx)(i.code,{children:"apply_cnot_gate(self, control_qubit_index, target_qubit_index)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a Controlled-NOT (CNOT) gate between two qubits."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"control_qubit_index"})," (int): Index of the control qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"target_qubit_index"})," (int): Index of the target qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Fundamental for entangling qubits, which is essential for quantum algorithms."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_toffoli_gateself-control_qubit_index1-control_qubit_index2-target_qubit_index",children:(0,s.jsx)(i.code,{children:"apply_toffoli_gate(self, control_qubit_index1, control_qubit_index2, target_qubit_index)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a Toffoli gate (CCX gate) to three qubits."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"control_qubit_index1"})," (int): Index of the first control qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"control_qubit_index2"})," (int): Index of the second control qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"target_qubit_index"})," (int): Index of the target qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Acts as a quantum AND gate, used in algorithms requiring conditional logic."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_swap_gateself-qubit_index1-qubit_index2",children:(0,s.jsx)(i.code,{children:"apply_swap_gate(self, qubit_index1, qubit_index2)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Swaps the states of two qubits."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index1"})," (int): Index of the first qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index2"})," (int): Index of the second qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Useful in quantum algorithms for rearranging qubit states."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_cswap_gateself-control_qubit_index-target_qubit_index1-target_qubit_index2",children:(0,s.jsx)(i.code,{children:"apply_cswap_gate(self, control_qubit_index, target_qubit_index1, target_qubit_index2)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a controlled-SWAP (Fredkin) gate that swaps two targets when the control is |1\u27e9."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"control_qubit_index"})," (int): Index of the control qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"target_qubit_index1"})," (int): Index of the first target qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"target_qubit_index2"})," (int): Index of the second target qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Used in overlap estimation routines such as the swap test."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_pauli_x_gateself-qubit_index",children:(0,s.jsx)(i.code,{children:"apply_pauli_x_gate(self, qubit_index)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a Pauli-X gate to a specified qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index"})," (int): Index of the qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Equivalent to a NOT gate, flips the qubit state."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_pauli_y_gateself-qubit_index",children:(0,s.jsx)(i.code,{children:"apply_pauli_y_gate(self, qubit_index)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a Pauli-Y gate to a specified qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index"})," (int): Index of the qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Impacts the phase and amplitude of a qubit's state."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_pauli_z_gateself-qubit_index",children:(0,s.jsx)(i.code,{children:"apply_pauli_z_gate(self, qubit_index)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a Pauli-Z gate to a specified qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index"})," (int): Index of the qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Alters the phase of a qubit without changing its amplitude."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_t_gateself-qubit_index",children:(0,s.jsx)(i.code,{children:"apply_t_gate(self, qubit_index)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies the T (\u03c0/8) phase gate to a specified qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index"})," (int): Index of the qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Adds a \u03c0/4 phase to |1\u27e9. Together with the Hadamard (H) and CNOT gates, it enables universal single-qubit control."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"execute_circuitself",children:(0,s.jsx)(i.code,{children:"execute_circuit(self)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Executes the quantum circuit and retrieves the results."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Used to run the entire set of quantum operations and measure the outcomes."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"get_final_state_vectorself",children:(0,s.jsx)(i.code,{children:"get_final_state_vector(self)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Returns the final state vector of the circuit from the configured backend."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Retrieves the full quantum state for simulation and analysis workflows."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"draw_circuitself",children:(0,s.jsx)(i.code,{children:"draw_circuit(self)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Visualizes the quantum circuit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Returns"}),": A string representation of the circuit visualization (format depends on backend)."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Returns a visualization string that can be printed or used programmatically. Example: ",(0,s.jsx)(i.code,{children:"print(qc.draw_circuit())"})," or ",(0,s.jsx)(i.code,{children:"viz = qc.draw_circuit()"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Note"}),": Uses underlying libraries' methods for drawing circuits (Qiskit's ",(0,s.jsx)(i.code,{children:"draw()"}),", Cirq's ",(0,s.jsx)(i.code,{children:"str()"}),", or Braket's ",(0,s.jsx)(i.code,{children:"str()"}),")."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_rx_gateself-qubit_index-angle",children:(0,s.jsx)(i.code,{children:"apply_rx_gate(self, qubit_index, angle)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a rotation around the X-axis to a specified qubit with an optional parameter for optimization."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index"})," (int): Index of the qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"angle"})," (str or float): Angle in radians for the rotation. Can be a static value or a parameter name for optimization."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Used to rotate a qubit around the X-axis, often in parameterized quantum circuits for variational algorithms."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_ry_gateself-qubit_index-angle",children:(0,s.jsx)(i.code,{children:"apply_ry_gate(self, qubit_index, angle)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a rotation around the Y-axis to a specified qubit with an optional parameter for optimization."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index"})," (int): Index of the qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"angle"})," (str or float): Angle in radians for the rotation. Can be a static value or a parameter name for optimization."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Used to rotate a qubit around the Y-axis in parameterized circuits, aiding in the creation of complex quantum states."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_rz_gateself-qubit_index-angle",children:(0,s.jsx)(i.code,{children:"apply_rz_gate(self, qubit_index, angle)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies a rotation around the Z-axis to a specified qubit with an optional parameter for optimization."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index"})," (int): Index of the qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"angle"})," (str or float): Angle in radians for the rotation. Can be a static value or a parameter name for optimization."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Utilized in parameterized quantum circuits to modify the phase of a qubit state during optimization."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"apply_u_gateself-qubit_index-theta-phi-lambd",children:(0,s.jsx)(i.code,{children:"apply_u_gate(self, qubit_index, theta, phi, lambd)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Applies the universal single-qubit U(\u03b8, \u03c6, \u03bb) gate."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit_index"})," (int): Index of the qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"theta"})," (float): Rotation angle \u03b8."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"phi"})," (float): Rotation angle \u03c6."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"lambd"})," (float): Rotation angle \u03bb."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Provides full single-qubit unitary control via Z\u2013Y\u2013Z Euler decomposition."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"execute_circuitself-parameter_valuesnone",children:(0,s.jsx)(i.code,{children:"execute_circuit(self, parameter_values=None)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Executes the quantum circuit with the ability to bind specific parameter values if provided."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"parameter_values"})," (dict, optional): A dictionary where keys are parameter names and values are the numerical values to bind."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Enables the execution of parameterized circuits by binding parameter values, facilitating optimization processes."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"bind_parametersself-parameter_values",children:(0,s.jsx)(i.code,{children:"bind_parameters(self, parameter_values)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Binds numerical values to the parameters of the quantum circuit, allowing for dynamic updates during optimization."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"parameter_values"})," (dict): A dictionary with parameter names as keys and numerical values to bind."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Essential for optimization loops where parameters are adjusted based on cost function evaluations."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"_handle_parameterself-param_name",children:(0,s.jsx)(i.code,{children:"_handle_parameter(self, param_name)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Internal function to manage parameter registration."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"param_name"})," (str): The name of the parameter to handle."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Automatically invoked when applying parameterized gates to keep track of parameters efficiently."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"swap_testself-ancilla_qubit-qubit1-qubit2",children:(0,s.jsx)(i.code,{children:"swap_test(self, ancilla_qubit, qubit1, qubit2)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Builds the swap-test subcircuit (H\u2013CSWAP\u2013H) to compare two quantum states."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"ancilla_qubit"})," (int): Index of the ancilla control qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit1"})," (int): Index of the first state qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit2"})," (int): Index of the second state qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Used in overlap/fidelity estimation between two states."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"measure_overlapself-qubit1-qubit2-ancilla_qubit0",children:(0,s.jsx)(i.code,{children:"measure_overlap(self, qubit1, qubit2, ancilla_qubit=0)"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Purpose"}),": Executes the swap test and returns |\u27e8\u03c8|\u03c6\u27e9|\xb2 using backend-specific measurement parsing."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Parameters"}),":\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit1"})," (int): Index of the first state qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"qubit2"})," (int): Index of the second state qubit."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"ancilla_qubit"})," (int, default to 0): Index of the ancilla qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Usage"}),": Convenience wrapper for fidelity/overlap measurement across backends."]}),"\n"]})]})}function u(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453(e,i,n){n.d(i,{R:()=>r,x:()=>a});var t=n(6540);const s={},l=t.createContext(s);function r(e){const i=t.useContext(l);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(l.Provider,{value:i},e.children)}}}]);