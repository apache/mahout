"use strict";(globalThis.webpackChunkmahout_website=globalThis.webpackChunkmahout_website||[]).push([[1056],{4702(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>a,frontMatter:()=>c,metadata:()=>d,toc:()=>o});const d=JSON.parse('{"id":"qdp/python-api","title":"Python Api","description":"Public Python API for QDP: GPU-accelerated encoding, benchmark helpers, and a batch iterator for training or evaluation loops.","source":"@site/versioned_docs/version-0.5/qdp/python-api.md","sourceDirName":"qdp","slug":"/qdp/python-api","permalink":"/docs/qdp/python-api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/mahout/tree/main/docs/versioned_docs/version-0.5/qdp/python-api.md","tags":[],"version":"0.5","frontMatter":{"title":"Python Api"}}');var s=r(4848),i=r(8453);const c={title:"Python Api"},t="QDP Python API (qumat_qdp)",l={},o=[{value:"Overview",id:"overview",level:2},{value:"Encoding API",id:"encoding-api",level:2},{value:"QdpEngine",id:"qdpengine",level:3},{value:"QuantumTensor",id:"quantumtensor",level:3},{value:"Benchmark API",id:"benchmark-api",level:2},{value:"QdpBenchmark",id:"qdpbenchmark",level:3},{value:"Result types",id:"result-types",level:3},{value:"Example",id:"example",level:3},{value:"Data Loader API",id:"data-loader-api",level:2},{value:"QuantumDataLoader",id:"quantumdataloader",level:3},{value:"Example",id:"example-1",level:3},{value:"Low-level: run_throughput_pipeline_py",id:"low-level-run_throughput_pipeline_py",level:2},{value:"Backward compatibility",id:"backward-compatibility",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"qdp-python-api-qumat_qdp",children:"QDP Python API (qumat_qdp)"})}),"\n",(0,s.jsx)(n.p,{children:"Public Python API for QDP: GPU-accelerated encoding, benchmark helpers, and a batch iterator for training or evaluation loops."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"qumat_qdp"})," package wraps the native extension ",(0,s.jsx)(n.code,{children:"_qdp"})," and adds:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Encoding:"})," ",(0,s.jsx)(n.code,{children:"QdpEngine"})," and ",(0,s.jsx)(n.code,{children:"QuantumTensor"})," for encoding classical data into quantum states and zero-copy DLPack integration."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Benchmark:"})," ",(0,s.jsx)(n.code,{children:"QdpBenchmark"})," for throughput/latency runs (full pipeline in Rust, GIL released)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Data loader:"})," ",(0,s.jsx)(n.code,{children:"QuantumDataLoader"})," for iterating encoded batches one at a time (",(0,s.jsx)(n.code,{children:"for qt in loader:"}),")."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Import from the package:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from qumat_qdp import (\n    QdpEngine,\n    QuantumTensor,\n    QdpBenchmark,\n    ThroughputResult,\n    LatencyResult,\n    QuantumDataLoader,\n    run_throughput_pipeline_py,\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Requirements:"})," Linux with NVIDIA GPU (CUDA). Loader and pipeline helpers are stubs on other platforms and raise ",(0,s.jsx)(n.code,{children:"RuntimeError"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"encoding-api",children:"Encoding API"}),"\n",(0,s.jsx)(n.h3,{id:"qdpengine",children:"QdpEngine"}),"\n",(0,s.jsx)(n.p,{children:"GPU encoder. Constructor and main methods:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:'QdpEngine(device_id=0, precision="float32")'})})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"device_id"})," (int): CUDA device ID."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"precision"})," (str): ",(0,s.jsx)(n.code,{children:'"float32"'})," or ",(0,s.jsx)(n.code,{children:'"float64"'}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Raises ",(0,s.jsx)(n.code,{children:"RuntimeError"})," on init failure or unsupported precision."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:'encode(data, num_qubits, encoding_method="amplitude") -> QuantumTensor'})})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data"}),": list of floats, 1D/2D NumPy array (float64, C-contiguous), PyTorch tensor (CPU/CUDA), or file path (",(0,s.jsx)(n.code,{children:".parquet"}),", ",(0,s.jsx)(n.code,{children:".arrow"}),", ",(0,s.jsx)(n.code,{children:".feather"}),", ",(0,s.jsx)(n.code,{children:".npy"}),", ",(0,s.jsx)(n.code,{children:".pt"}),", ",(0,s.jsx)(n.code,{children:".pth"}),", ",(0,s.jsx)(n.code,{children:".pb"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"num_qubits"})," (int): Number of qubits."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"encoding_method"})," (str): ",(0,s.jsx)(n.code,{children:'"amplitude"'})," | ",(0,s.jsx)(n.code,{children:'"angle"'})," | ",(0,s.jsx)(n.code,{children:'"basis"'})," | ",(0,s.jsx)(n.code,{children:'"iqp"'})," | ",(0,s.jsx)(n.code,{children:'"iqp-z"'}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Returns a DLPack-compatible tensor; use ",(0,s.jsx)(n.code,{children:"torch.from_dlpack(qtensor)"}),". Shape ",(0,s.jsx)(n.code,{children:"[batch_size, 2^num_qubits]"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:'create_synthetic_loader(total_batches, batch_size=64, num_qubits=16, encoding_method="amplitude", seed=None)'})})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Returns an iterator that yields one ",(0,s.jsx)(n.code,{children:"QuantumTensor"})," per batch. GIL is released during each encode. Linux/CUDA only."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"quantumtensor",children:"QuantumTensor"}),"\n",(0,s.jsx)(n.p,{children:"DLPack wrapper for a GPU quantum state."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"__dlpack__(stream=None)"}),":"]})," Returns a DLPack PyCapsule (single use)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"__dlpack_device__()"}),":"]})," Returns ",(0,s.jsx)(n.code,{children:"(device_type, device_id)"}),"; CUDA is ",(0,s.jsx)(n.code,{children:"(2, gpu_id)"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If not consumed, memory is freed when the object is dropped; if consumed (e.g. by PyTorch), ownership transfers to the consumer."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"benchmark-api",children:"Benchmark API"}),"\n",(0,s.jsx)(n.p,{children:"Runs the full encode pipeline in Rust (warmup + timed loop) with GIL released. No Python-side loop."}),"\n",(0,s.jsx)(n.h3,{id:"qdpbenchmark",children:"QdpBenchmark"}),"\n",(0,s.jsxs)(n.p,{children:["Builder; chain methods then call ",(0,s.jsx)(n.code,{children:"run_throughput()"})," or ",(0,s.jsx)(n.code,{children:"run_latency()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Constructor:"})," ",(0,s.jsx)(n.code,{children:"QdpBenchmark(device_id=0)"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Chainable methods:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"qubits(n)"})}),(0,s.jsx)(n.td,{children:"Number of qubits."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"encoding(method)"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:'"amplitude"'})," | ",(0,s.jsx)(n.code,{children:'"angle"'})," | ",(0,s.jsx)(n.code,{children:'"basis"'}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"batches(total, size=64)"})}),(0,s.jsx)(n.td,{children:"Total batches and batch size."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"prefetch(n)"})}),(0,s.jsx)(n.td,{children:"No-op (API compatibility)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"warmup(n)"})}),(0,s.jsx)(n.td,{children:"Warmup batch count."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"run_throughput() -> ThroughputResult"})})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Requires ",(0,s.jsx)(n.code,{children:"qubits"})," and ",(0,s.jsx)(n.code,{children:"batches"})," to be set."]}),"\n",(0,s.jsxs)(n.li,{children:["Returns ",(0,s.jsx)(n.code,{children:"ThroughputResult"})," with ",(0,s.jsx)(n.code,{children:"duration_sec"}),", ",(0,s.jsx)(n.code,{children:"vectors_per_sec"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Raises ",(0,s.jsx)(n.code,{children:"ValueError"})," if config missing; ",(0,s.jsx)(n.code,{children:"RuntimeError"})," if pipeline unavailable."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"run_latency() -> LatencyResult"})})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Same pipeline; returns ",(0,s.jsx)(n.code,{children:"LatencyResult"})," with ",(0,s.jsx)(n.code,{children:"duration_sec"}),", ",(0,s.jsx)(n.code,{children:"latency_ms_per_vector"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"result-types",children:"Result types"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Fields"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ThroughputResult"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"duration_sec"}),", ",(0,s.jsx)(n.code,{children:"vectors_per_sec"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LatencyResult"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"duration_sec"}),", ",(0,s.jsx)(n.code,{children:"latency_ms_per_vector"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from qumat_qdp import QdpBenchmark, ThroughputResult, LatencyResult\n\nresult = (\n    QdpBenchmark(device_id=0)\n    .qubits(16)\n    .encoding("amplitude")\n    .batches(100, size=64)\n    .warmup(2)\n    .run_throughput()\n)\nprint(result.vectors_per_sec)\n\nlat = (\n    QdpBenchmark(device_id=0)\n    .qubits(16)\n    .encoding("amplitude")\n    .batches(100, size=64)\n    .run_latency()\n)\nprint(lat.latency_ms_per_vector)\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"data-loader-api",children:"Data Loader API"}),"\n",(0,s.jsxs)(n.p,{children:["Iterate over encoded batches one at a time. Each batch is a ",(0,s.jsx)(n.code,{children:"QuantumTensor"}),"; encoding runs in Rust with GIL released per batch."]}),"\n",(0,s.jsx)(n.h3,{id:"quantumdataloader",children:"QuantumDataLoader"}),"\n",(0,s.jsxs)(n.p,{children:["Builder for a synthetic-data loader. Calling ",(0,s.jsx)(n.code,{children:"iter(loader)"})," (or ",(0,s.jsx)(n.code,{children:"for qt in loader"}),") creates the Rust-backed iterator."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Constructor:"}),"\n",(0,s.jsx)(n.code,{children:'QuantumDataLoader(device_id=0, num_qubits=16, batch_size=64, total_batches=100, encoding_method="amplitude", seed=None)'})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Chainable methods:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Method"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"qubits(n)"})}),(0,s.jsx)(n.td,{children:"Number of qubits."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"encoding(method)"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:'"amplitude"'})," | ",(0,s.jsx)(n.code,{children:'"angle"'})," | ",(0,s.jsx)(n.code,{children:'"basis"'}),"."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"batches(total, size=64)"})}),(0,s.jsx)(n.td,{children:"Total batches and batch size."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"source_synthetic(total_batches=None)"})}),(0,s.jsx)(n.td,{children:"Synthetic data (default); optional override for total batches."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"seed(s)"})}),(0,s.jsx)(n.td,{children:"RNG seed for reproducibility."})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Iteration:"})," ",(0,s.jsx)(n.code,{children:"for qt in loader:"})," yields ",(0,s.jsx)(n.code,{children:"QuantumTensor"})," of shape ",(0,s.jsx)(n.code,{children:"[batch_size, 2^num_qubits]"}),". Consume once per tensor, e.g. ",(0,s.jsx)(n.code,{children:"torch.from_dlpack(qt)"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from qumat_qdp import QuantumDataLoader\nimport torch\n\nloader = (\n    QuantumDataLoader(device_id=0)\n    .qubits(16)\n    .encoding("amplitude")\n    .batches(100, size=64)\n    .source_synthetic()\n)\n\nfor qt in loader:\n    batch = torch.from_dlpack(qt)  # [batch_size, 2^16]\n    # use batch ...\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"low-level-run_throughput_pipeline_py",children:"Low-level: run_throughput_pipeline_py"}),"\n",(0,s.jsxs)(n.p,{children:["Runs the full pipeline in Rust with GIL released. Used by ",(0,s.jsx)(n.code,{children:"QdpBenchmark"}),"; can be called directly."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Signature:"}),"\n",(0,s.jsx)(n.code,{children:'run_throughput_pipeline_py(device_id=0, num_qubits=16, batch_size=64, total_batches=100, encoding_method="amplitude", warmup_batches=0, seed=None) -> tuple[float, float, float]'})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns:"})," ",(0,s.jsx)(n.code,{children:"(duration_sec, vectors_per_sec, latency_ms_per_vector)"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Raises:"})," ",(0,s.jsx)(n.code,{children:"RuntimeError"})," on failure or when not available (e.g. non-Linux)."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"backward-compatibility",children:"Backward compatibility"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"benchmark/api.py"})," and ",(0,s.jsx)(n.code,{children:"benchmark/loader.py"})," re-export from ",(0,s.jsx)(n.code,{children:"qumat_qdp"}),". Prefer:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"from qumat_qdp import QdpBenchmark, ThroughputResult, LatencyResult"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"from qumat_qdp import QuantumDataLoader"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Benchmark scripts add the project root to ",(0,s.jsx)(n.code,{children:"sys.path"}),", so from the ",(0,s.jsx)(n.code,{children:"qdp-python"})," directory you can run:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"uv run python benchmark/run_pipeline_baseline.py\nuv run python benchmark/benchmark_loader_throughput.py\n"})}),"\n",(0,s.jsxs)(n.p,{children:["without setting ",(0,s.jsx)(n.code,{children:"PYTHONPATH"}),"."]})]})}function a(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453(e,n,r){r.d(n,{R:()=>c,x:()=>t});var d=r(6540);const s={},i=d.createContext(s);function c(e){const n=d.useContext(i);return d.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),d.createElement(i.Provider,{value:n},e.children)}}}]);