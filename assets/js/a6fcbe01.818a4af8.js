"use strict";(globalThis.webpackChunkmahout_website=globalThis.webpackChunkmahout_website||[]).push([[5157],{6703(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"advanced/gap-analysis","title":"Gap Analysis","description":"This analysis examines the provided qumat codebase to identify the necessary modifications and additions required to implement Parameterized Quantum Circuits (PQCs). The analysis is divided into two parts:","source":"@site/docs/advanced/gap-analysis.md","sourceDirName":"advanced","slug":"/advanced/gap-analysis","permalink":"/docs/next/advanced/gap-analysis","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/mahout/tree/main/docs/docs/advanced/gap-analysis.md","tags":[],"version":"current","frontMatter":{"title":"Gap Analysis"},"sidebar":"docsSidebar","previous":{"title":"Pqc","permalink":"/docs/next/advanced/pqc"},"next":{"title":"Quantum Computing Primer","permalink":"/docs/next/learning/quantum-computing-primer/"}}');var r=i(4848),s=i(8453);const a={title:"Gap Analysis"},l="Analysis of the QuMat Codebase for Implementing Parameterized Quantum Circuits",o={},d=[{value:"Overview of the QuMat Codebase",id:"overview-of-the-qumat-codebase",level:2},{value:"Part 1: Minimally Viable Product for PQCs",id:"part-1-minimally-viable-product-for-pqcs",level:2},{value:"1. Support for Parameterized Gates",id:"1-support-for-parameterized-gates",level:3},{value:"2. Parameter Handling",id:"2-parameter-handling",level:3},{value:"3. Execution with Parameter Values",id:"3-execution-with-parameter-values",level:3},{value:"4. Basic Optimization Loop",id:"4-basic-optimization-loop",level:3},{value:"Part 2: Feature-Complete Implementation for PQCs",id:"part-2-feature-complete-implementation-for-pqcs",level:2},{value:"1. Automatic Differentiation and Gradient Computation",id:"1-automatic-differentiation-and-gradient-computation",level:3},{value:"2. Advanced Parameter Management",id:"2-advanced-parameter-management",level:3},{value:"3. Support for Circuit Ans\xe4tze",id:"3-support-for-circuit-ans\xe4tze",level:3},{value:"4. Integration of Optimization Algorithms",id:"4-integration-of-optimization-algorithms",level:3},{value:"5. Measurement and Expectation Value Computation",id:"5-measurement-and-expectation-value-computation",level:3},{value:"6. Noise Modeling and Error Mitigation",id:"6-noise-modeling-and-error-mitigation",level:3},{value:"7. Advanced Circuit Visualization",id:"7-advanced-circuit-visualization",level:3},{value:"8. Extensible Backend Support",id:"8-extensible-backend-support",level:3},{value:"9. Comprehensive Testing Suite",id:"9-comprehensive-testing-suite",level:3},{value:"10. Documentation and User Guides",id:"10-documentation-and-user-guides",level:3},{value:"11. Hardware Execution Support",id:"11-hardware-execution-support",level:3},{value:"12. Community and Extensibility",id:"12-community-and-extensibility",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"analysis-of-the-qumat-codebase-for-implementing-parameterized-quantum-circuits",children:"Analysis of the QuMat Codebase for Implementing Parameterized Quantum Circuits"})}),"\n",(0,r.jsxs)(n.p,{children:["This analysis examines the provided ",(0,r.jsx)(n.code,{children:"qumat"})," codebase to identify the necessary modifications and additions required to implement Parameterized Quantum Circuits (PQCs). The analysis is divided into two parts:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimally Viable Product (MVP):"})," Outlines the essential features and changes needed to support basic PQC functionality."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Feature-Complete Implementation:"})," Details the additional features and improvements needed to create a robust and comprehensive PQC framework."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"overview-of-the-qumat-codebase",children:"Overview of the QuMat Codebase"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"qumat"})," codebase is designed to provide a unified interface for quantum circuit simulation across multiple backends, including Qiskit, Cirq, and Amazon Braket. The core components include:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backend Modules:"})," Separate modules for each supported backend (",(0,r.jsx)(n.code,{children:"qiskit_backend.py"}),", ",(0,r.jsx)(n.code,{children:"cirq_backend.py"}),", ",(0,r.jsx)(n.code,{children:"amazon_braket_backend.py"}),") containing functions to manipulate quantum circuits using the respective libraries."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["QuMat Class (",(0,r.jsx)(n.code,{children:"qumat.py"}),"):"]})," A class that abstracts backend-specific operations and provides methods to create circuits and apply standard quantum gates."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Currently, the codebase allows users to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Create quantum circuits."}),"\n",(0,r.jsx)(n.li,{children:"Apply a fixed set of quantum gates (NOT, Hadamard, CNOT, Toffoli, SWAP, Pauli X/Y/Z)."}),"\n",(0,r.jsx)(n.li,{children:"Execute circuits and obtain measurement results."}),"\n",(0,r.jsx)(n.li,{children:"Draw circuits (limited support, backend-dependent)."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"part-1-minimally-viable-product-for-pqcs",children:"Part 1: Minimally Viable Product for PQCs"}),"\n",(0,r.jsx)(n.p,{children:"To support basic PQC functionality, the following features and modifications are necessary:"}),"\n",(0,r.jsx)(n.h3,{id:"1-support-for-parameterized-gates",children:"1. Support for Parameterized Gates"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Shortcoming:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The current implementation only includes fixed gates without parameters (e.g., NOT, Hadamard, CNOT)."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Changes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Implement Parameterized Gate Methods:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Add functions to apply parameterized rotation gates such as ",(0,r.jsx)(n.code,{children:"R_X(\u03b8)"}),", ",(0,r.jsx)(n.code,{children:"R_Y(\u03b8)"}),", ",(0,r.jsx)(n.code,{children:"R_Z(\u03b8)"}),", and general single-qubit rotation ",(0,r.jsx)(n.code,{children:"U(\u03b8, \u03c6, \u03bb)"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Ensure these methods accept continuous parameters (e.g., rotation angles)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Example Function Signature:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def apply_rotation_x_gate(circuit, qubit_index, theta):\n    # Implementation for rotation around X-axis by angle theta\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-parameter-handling",children:"2. Parameter Handling"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Shortcoming:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No mechanism to store and update gate parameters within the circuit."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Changes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameter Management:"}),"\nUse variables or symbols to represent parameters that can be updated during optimization.\nEnsure that the parameters are accessible and modifiable after circuit creation."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-execution-with-parameter-values",children:"3. Execution with Parameter Values"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Shortcoming:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Execution functions do not account for circuits with variable parameters."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Changes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Bind Parameter Values at Execution:"}),"\n",(0,r.jsx)(n.li,{children:"Modify the execution functions to accept parameter values and bind them to the circuit before execution."}),"\n",(0,r.jsx)(n.li,{children:"Ensure backends support parameter binding (may require additional handling for different libraries)."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-basic-optimization-loop",children:"4. Basic Optimization Loop"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Shortcoming:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No functionality for optimizing parameters (e.g., gradient descent)."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Changes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simple Parameter Update Mechanism:"}),"\n",(0,r.jsx)(n.li,{children:"Implement a basic optimization loop outside the qumat library, where parameter values are updated based on cost function evaluations."}),"\n",(0,r.jsx)(n.li,{children:"Provide support for running circuits with updated parameters."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"part-2-feature-complete-implementation-for-pqcs",children:"Part 2: Feature-Complete Implementation for PQCs"}),"\n",(0,r.jsx)(n.p,{children:"To create a comprehensive PQC framework, the following features and enhancements are needed:"}),"\n",(0,r.jsx)(n.h3,{id:"1-automatic-differentiation-and-gradient-computation",children:"1. Automatic Differentiation and Gradient Computation"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Shortcoming:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No support for computing gradients of the cost function with respect to circuit parameters."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Additions:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameter Shift Rule Implementation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement the parameter shift rule to compute exact gradients for parameterized gates."}),"\n",(0,r.jsx)(n.li,{children:"Provide functions to calculate gradients efficiently."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Integration with Automatic Differentiation Libraries:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"(Optional) Integrate with libraries that support automatic differentiation to handle complex circuits."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-advanced-parameter-management",children:"2. Advanced Parameter Management"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Enhancements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Symbolic Parameters:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement a system to handle symbolic parameters, enabling complex parameter relationships and shared parameters across gates."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameter Dictionaries:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use dictionaries or parameter objects to manage parameter values and updates systematically."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-support-for-circuit-ans\xe4tze",children:"3. Support for Circuit Ans\xe4tze"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Shortcoming:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No predefined circuit structures (ans\xe4tze) commonly used in PQCs."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Additions:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Circuit Templates:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement functions to generate commonly used PQC ans\xe4tze, such as hardware-efficient ansatz or layered variational circuits."}),"\n",(0,r.jsx)(n.li,{children:"Allow customization of ansatz depth and structure."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-integration-of-optimization-algorithms",children:"4. Integration of Optimization Algorithms"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Shortcoming:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lack of built-in optimization routines for training PQCs."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Additions:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimization Module:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Include various classical optimization algorithms (gradient-based and gradient-free) tailored for quantum circuits."}),"\n",(0,r.jsx)(n.li,{children:"Provide interfaces for selecting and configuring optimization strategies."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"5-measurement-and-expectation-value-computation",children:"5. Measurement and Expectation Value Computation"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Enhancements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Expectation Values:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement functions to compute expectation values of observables, which are crucial for many VQAs."}),"\n",(0,r.jsx)(n.li,{children:"Support measurement of arbitrary operators through decomposition into measurable components."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"6-noise-modeling-and-error-mitigation",children:"6. Noise Modeling and Error Mitigation"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Shortcoming:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No support for simulating noise or implementing error mitigation techniques."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Additions:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Noise Models:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Incorporate noise modeling capabilities to simulate realistic hardware conditions."}),"\n",(0,r.jsx)(n.li,{children:"Allow users to define noise parameters and types (e.g., depolarizing noise, readout errors)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Error Mitigation Techniques:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement methods like zero-noise extrapolation or probabilistic error cancellation."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"7-advanced-circuit-visualization",children:"7. Advanced Circuit Visualization"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Enhancements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Improved Circuit Drawing:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Develop a unified circuit drawing utility that provides clear and informative visualizations across backends."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"8-extensible-backend-support",children:"8. Extensible Backend Support"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Enhancements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backend Abstraction Improvements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Refine the backend interface to support additional libraries or custom simulators."}),"\n",(0,r.jsx)(n.li,{children:"Ensure consistent behavior and capabilities across different backends."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"9-comprehensive-testing-suite",children:"9. Comprehensive Testing Suite"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Shortcoming:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Limited testing and validation mechanisms."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Required Additions:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unit Tests and Integration Tests:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Develop thorough tests for all functionalities, including parameterized gates, optimization routines, and backends."}),"\n",(0,r.jsx)(n.li,{children:"Validate correctness and performance."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"10-documentation-and-user-guides",children:"10. Documentation and User Guides"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Enhancements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Detailed Documentation:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Create comprehensive documentation covering all aspects of the library."}),"\n",(0,r.jsx)(n.li,{children:"Include tutorials and examples demonstrating how to implement various PQCs and algorithms."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"11-hardware-execution-support",children:"11. Hardware Execution Support"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Enhancements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real Hardware Integration:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Provide support for executing circuits on actual quantum hardware (where available)."}),"\n",(0,r.jsx)(n.li,{children:"Handle job submission, monitoring, and result retrieval for hardware devices."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"12-community-and-extensibility",children:"12. Community and Extensibility"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Enhancements:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Plugin System:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Design the codebase to be extensible, allowing users to add custom gates, ans\xe4tze, or optimization algorithms."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Community Contributions:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Set up guidelines and infrastructure to encourage community involvement."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453(e,n,i){i.d(n,{R:()=>a,x:()=>l});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);