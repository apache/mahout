"use strict";(globalThis.webpackChunkmahout_website=globalThis.webpackChunkmahout_website||[]).push([[6190],{1754(e,r,n){n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"qdp/readers","title":"Readers","description":"This document describes the refactored input handling system in QDP that makes it easy to support multiple data formats.","source":"@site/versioned_docs/version-0.4/qdp/readers.md","sourceDirName":"qdp","slug":"/qdp/readers","permalink":"/docs/0.4/qdp/readers","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/mahout/tree/main/docs/versioned_docs/version-0.4/qdp/readers.md","tags":[],"version":"0.4","frontMatter":{"title":"Readers"},"sidebar":"docsSidebar","previous":{"title":"Observability","permalink":"/docs/0.4/qdp/observability"},"next":{"title":"Testing","permalink":"/docs/0.4/qdp/testing"}}');var i=n(4848),a=n(8453);const t={title:"Readers"},d="QDP Input Format Architecture",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Core Traits",id:"core-traits",level:3},{value:"<code>DataReader</code> Trait",id:"datareader-trait",level:4},{value:"<code>StreamingDataReader</code> Trait",id:"streamingdatareader-trait",level:4},{value:"Implemented Formats",id:"implemented-formats",level:3},{value:"Benefits",id:"benefits",level:2},{value:"1. Easy Extension",id:"1-easy-extension",level:3},{value:"2. Zero Performance Overhead",id:"2-zero-performance-overhead",level:3},{value:"3. Backward Compatibility",id:"3-backward-compatibility",level:3},{value:"4. Polymorphic Usage",id:"4-polymorphic-usage",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Reading",id:"basic-reading",level:3},{value:"Streaming Large Files",id:"streaming-large-files",level:3},{value:"Format Detection",id:"format-detection",level:3},{value:"Adding New Formats",id:"adding-new-formats",level:2},{value:"File Organization",id:"file-organization",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Memory Efficiency",id:"memory-efficiency",level:3},{value:"Speed",id:"speed",level:3},{value:"Benchmarks",id:"benchmarks",level:3},{value:"Migration Guide",id:"migration-guide",level:2},{value:"For Users",id:"for-users",level:3},{value:"For Contributors",id:"for-contributors",level:3},{value:"Future Enhancements",id:"future-enhancements",level:2},{value:"Questions?",id:"questions",level:2}];function o(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"qdp-input-format-architecture",children:"QDP Input Format Architecture"})}),"\n",(0,i.jsx)(r.p,{children:"This document describes the refactored input handling system in QDP that makes it easy to support multiple data formats."}),"\n",(0,i.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(r.p,{children:"QDP now uses a trait-based architecture for reading quantum data from various sources. This design allows adding new input formats (NumPy, PyTorch, HDF5, etc.) without modifying core library code."}),"\n",(0,i.jsx)(r.h2,{id:"architecture",children:"Architecture"}),"\n",(0,i.jsx)(r.h3,{id:"core-traits",children:"Core Traits"}),"\n",(0,i.jsxs)(r.h4,{id:"datareader-trait",children:[(0,i.jsx)(r.code,{children:"DataReader"})," Trait"]}),"\n",(0,i.jsx)(r.p,{children:"Basic interface for batch reading:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"pub trait DataReader {\n    fn read_batch(&mut self) -> Result<(Vec<f64>, usize, usize)>;\n    fn get_sample_size(&self) -> Option<usize> { None }\n    fn get_num_samples(&self) -> Option<usize> { None }\n}\n"})}),"\n",(0,i.jsxs)(r.h4,{id:"streamingdatareader-trait",children:[(0,i.jsx)(r.code,{children:"StreamingDataReader"})," Trait"]}),"\n",(0,i.jsx)(r.p,{children:"Extended interface for large files that don't fit in memory:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"pub trait StreamingDataReader: DataReader {\n    fn read_chunk(&mut self, buffer: &mut [f64]) -> Result<usize>;\n    fn total_rows(&self) -> usize;\n}\n"})}),"\n",(0,i.jsx)(r.h3,{id:"implemented-formats",children:"Implemented Formats"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Format"}),(0,i.jsx)(r.th,{children:"Reader"}),(0,i.jsx)(r.th,{children:"Streaming"}),(0,i.jsx)(r.th,{children:"Status"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Parquet"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"ParquetReader"})}),(0,i.jsxs)(r.td,{children:["\u2705 ",(0,i.jsx)(r.code,{children:"ParquetStreamingReader"})]}),(0,i.jsx)(r.td,{children:"\u2705 Complete"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Arrow IPC"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"ArrowIPCReader"})}),(0,i.jsx)(r.td,{children:"\u274c"}),(0,i.jsx)(r.td,{children:"\u2705 Complete"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"NumPy"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"NumpyReader"})}),(0,i.jsx)(r.td,{children:"\u274c"}),(0,i.jsx)(r.td,{children:"\u2705 Complete"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"PyTorch"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"TorchReader"})}),(0,i.jsx)(r.td,{children:"\u274c"}),(0,i.jsxs)(r.td,{children:["\u2705 (feature: ",(0,i.jsx)(r.code,{children:"pytorch"}),")"]})]})]})]}),"\n",(0,i.jsx)(r.h2,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsx)(r.h3,{id:"1-easy-extension",children:"1. Easy Extension"}),"\n",(0,i.jsx)(r.p,{children:"Adding a new format requires only:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Implementing the ",(0,i.jsx)(r.code,{children:"DataReader"})," trait"]}),"\n",(0,i.jsxs)(r.li,{children:["Registering in ",(0,i.jsx)(r.code,{children:"readers/mod.rs"})]}),"\n",(0,i.jsx)(r.li,{children:"Optional: Add convenience functions"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"No changes to core QDP code needed!"}),"\n",(0,i.jsx)(r.h3,{id:"2-zero-performance-overhead",children:"2. Zero Performance Overhead"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Traits use static dispatch where possible"}),"\n",(0,i.jsx)(r.li,{children:"No runtime polymorphism overhead in hot paths"}),"\n",(0,i.jsx)(r.li,{children:"Same zero-copy and streaming capabilities as before"}),"\n",(0,i.jsx)(r.li,{children:"No memory allocation overhead"}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"3-backward-compatibility",children:"3. Backward Compatibility"}),"\n",(0,i.jsx)(r.p,{children:"All existing APIs continue to work:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'// Old API still works\nlet (data, samples, size) = read_parquet_batch("data.parquet")?;\nlet (data, samples, size) = read_arrow_ipc_batch("data.arrow")?;\n\n// ParquetBlockReader is now an alias to ParquetStreamingReader\nlet mut reader = ParquetBlockReader::new("data.parquet", None)?;\nreader.read_chunk(&mut buffer)?;\n'})}),"\n",(0,i.jsx)(r.h3,{id:"4-polymorphic-usage",children:"4. Polymorphic Usage"}),"\n",(0,i.jsx)(r.p,{children:"Readers can be used generically:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'fn process_data<R: DataReader>(mut reader: R) -> Result<()> {\n    let (data, samples, size) = reader.read_batch()?;\n    // Process data...\n}\n\n// Works with any reader!\nprocess_data(ParquetReader::new("data.parquet", None)?)?;\nprocess_data(ArrowIPCReader::new("data.arrow")?)?;\n'})}),"\n",(0,i.jsx)(r.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,i.jsx)(r.h3,{id:"basic-reading",children:"Basic Reading"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use qdp_core::reader::DataReader;\nuse qdp_core::readers::ArrowIPCReader;\n\nlet mut reader = ArrowIPCReader::new("quantum_states.arrow")?;\nlet (data, num_samples, sample_size) = reader.read_batch()?;\n\nprintln!("Read {} samples of {} qubits",\n         num_samples, (sample_size as f64).log2() as usize);\n'})}),"\n",(0,i.jsx)(r.h3,{id:"streaming-large-files",children:"Streaming Large Files"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'use qdp_core::reader::StreamingDataReader;\nuse qdp_core::readers::ParquetStreamingReader;\n\nlet mut reader = ParquetStreamingReader::new("large_dataset.parquet", None)?;\nlet mut buffer = vec![0.0; 1024 * 1024]; // 1M element buffer\n\nloop {\n    let written = reader.read_chunk(&mut buffer)?;\n    if written == 0 { break; }\n\n    // Process chunk\n    process_chunk(&buffer[..written])?;\n}\n'})}),"\n",(0,i.jsx)(r.h3,{id:"format-detection",children:"Format Detection"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:'fn read_quantum_data(path: &str) -> Result<(Vec<f64>, usize, usize)> {\n    use qdp_core::reader::DataReader;\n\n    if path.ends_with(".parquet") {\n        ParquetReader::new(path, None)?.read_batch()\n    } else if path.ends_with(".arrow") {\n        ArrowIPCReader::new(path)?.read_batch()\n    } else if path.ends_with(".npy") {\n        NumpyReader::new(path)?.read_batch()\n    } else if path.ends_with(".pt") || path.ends_with(".pth") {\n        TorchReader::new(path)?.read_batch()\n    } else {\n        Err(MahoutError::InvalidInput("Unsupported format".into()))\n    }\n}\n'})}),"\n",(0,i.jsx)(r.h2,{id:"adding-new-formats",children:"Adding New Formats"}),"\n",(0,i.jsx)(r.p,{children:"See ADDING_INPUT_FORMATS.md (TODO) for detailed instructions."}),"\n",(0,i.jsx)(r.p,{children:"Quick overview:"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:["Create ",(0,i.jsx)(r.code,{children:"readers/myformat.rs"})]}),"\n",(0,i.jsxs)(r.li,{children:["Implement ",(0,i.jsx)(r.code,{children:"DataReader"})," trait"]}),"\n",(0,i.jsxs)(r.li,{children:["Add to ",(0,i.jsx)(r.code,{children:"readers/mod.rs"})]}),"\n",(0,i.jsx)(r.li,{children:"Add tests"}),"\n",(0,i.jsx)(r.li,{children:"(Optional) Add convenience functions"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"file-organization",children:"File Organization"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"qdp-core/src/\n\u251c\u2500\u2500 reader.rs              # Trait definitions\n\u251c\u2500\u2500 readers/\n\u2502   \u251c\u2500\u2500 mod.rs            # Reader registry\n\u2502   \u251c\u2500\u2500 parquet.rs        # Parquet implementation\n\u2502   \u251c\u2500\u2500 arrow_ipc.rs      # Arrow IPC implementation\n\u2502   \u251c\u2500\u2500 numpy.rs          # NumPy implementation\n\u2502   \u2514\u2500\u2500 torch.rs          # PyTorch (feature-gated)\n\u251c\u2500\u2500 io.rs                 # Legacy API & helper functions\n\u2514\u2500\u2500 lib.rs                # Main library\n\nexamples/\n\u2514\u2500\u2500 flexible_readers.rs   # Demo of architecture\n\ndocs/\n\u251c\u2500\u2500 readers/\n\u2502   \u2514\u2500\u2500 README.md         # This file\n\u2514\u2500\u2500 ADDING_INPUT_FORMATS.md  # Extension guide\n"})}),"\n",(0,i.jsx)(r.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(r.h3,{id:"memory-efficiency",children:"Memory Efficiency"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Parquet Streaming"}),": Constant memory usage for any file size"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Zero-copy"}),": Direct buffer access where possible"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Pre-allocation"}),": Reserves capacity when total size is known"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"speed",children:"Speed"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Static dispatch"}),": No virtual function overhead"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Batch operations"}),": Minimizes function call overhead"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Efficient formats"}),": Columnar storage (Parquet/Arrow) for fast reading"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"benchmarks",children:"Benchmarks"}),"\n",(0,i.jsx)(r.p,{children:"The architecture maintains the same performance as before:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Parquet streaming: ~2GB/s throughput"}),"\n",(0,i.jsx)(r.li,{children:"Arrow IPC: ~4GB/s throughput (zero-copy)"}),"\n",(0,i.jsx)(r.li,{children:"Memory usage: O(buffer_size), not O(file_size)"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"migration-guide",children:"Migration Guide"}),"\n",(0,i.jsx)(r.h3,{id:"for-users",children:"For Users"}),"\n",(0,i.jsx)(r.p,{children:"No changes required! All existing code continues to work."}),"\n",(0,i.jsx)(r.h3,{id:"for-contributors",children:"For Contributors"}),"\n",(0,i.jsx)(r.p,{children:"If you were directly using internal reader structures:"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Before:"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"let reader = ParquetBlockReader::new(path, None)?;\n"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"After:"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-rust",children:"// Still works (it's a type alias)\nlet reader = ParquetBlockReader::new(path, None)?;\n\n// Or use the new name\nlet reader = ParquetStreamingReader::new(path, None)?;\n"})}),"\n",(0,i.jsx)(r.h2,{id:"future-enhancements",children:"Future Enhancements"}),"\n",(0,i.jsx)(r.p,{children:"Planned format support:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"NumPy streaming"}),": Chunked reads for large ",(0,i.jsx)(r.code,{children:".npy"})," files"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"PyTorch streaming"}),": Streaming support for large tensors"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"HDF5"})," (",(0,i.jsx)(r.code,{children:".h5"}),"): Scientific data storage"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"JSON"}),": Human-readable format for small datasets"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"CSV"}),": Simple tabular data"]}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"questions",children:"Questions?"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["See examples: ",(0,i.jsx)(r.code,{children:"cargo run --example flexible_readers"})]}),"\n",(0,i.jsx)(r.li,{children:"Read extension guide: ADDING_INPUT_FORMATS.md (TODO)"}),"\n",(0,i.jsxs)(r.li,{children:["Check tests: ",(0,i.jsx)(r.code,{children:"qdp-core/tests/*_io.rs"})]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453(e,r,n){n.d(r,{R:()=>t,x:()=>d});var s=n(6540);const i={},a=s.createContext(i);function t(e){const r=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(a.Provider,{value:r},e.children)}}}]);